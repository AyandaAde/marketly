diff --git a/app/api/match-with-consultant/route.ts b/app/api/match-with-consultant/route.ts
index 2264505..7fbb22a 100644
--- a/app/api/match-with-consultant/route.ts
+++ b/app/api/match-with-consultant/route.ts
@@ -1,105 +1,129 @@
+import { env } from "@/env";
+import { prisma } from "@/lib/db/prisma";
 import { NextRequest, NextResponse } from "next/server";
+import nodemailer from "nodemailer";
+import OpenAI from "openai";
+
+export const openai = new OpenAI({
+  apiKey: env.OPENAI_API_KEY,
+});
 
 export async function POST(req: NextRequest) {
+  const transporter = nodemailer.createTransport({
+    service: "gmail",
+    auth: {
+      user: env.EMAIL_USER,
+      pass: env.EMAIL_PASSWORD,
+    },
+    tls: {
+      rejectUnauthorized: false,
+    },
+  });
+
   try {
-    const { inquiry } = await req.json();
+    const { inquiry, email } = await req.json();
 
     if (!inquiry) {
-      throw new Error("Internal server error");
+      return new NextResponse("Error: Missing requirement inquiry", {
+        status: 400,
+        statusText: "Error: Missing requirement inquiry",
+      });
     }
 
-    const consultants = [
-      {
-        id: "1",
-        image: "/images/james-richardson.jpg",
-        name: "Mr.Jamees R",
-        email: "james@email.com",
-        title: "Consultant",
-        expertise: [
-          {
-            title: "Technology & Software Development",
-            value: "technology-and-software-development",
-          },
-          {
-            title: "SEO",
-            value: "seo",
-          },
-          { title: "General Consultation", value: "general-consultation" },
-          {
-            title: "Partnership Opportunity",
-            value: "partnership-opportunity",
-          },
-          {
-            title: "Other",
-            value: "other",
-          },
-        ],
-        initials: "JR",
-        location: "British Columbia, Canada",
-      },
-      {
-        id: "2",
-        image: "/images/lola-dam.jpg",
-        name: "Ms.Lola D",
-        email: "lola@email.com",
-        title: "Consultant",
-        expertise: [
-          {
-            title: "SEO",
-            value: "seo",
-          },
-          { title: "General Consultation", value: "general-consultation" },
-          {
-            title: "Partnership Opportunity",
-            value: "partnership-opportunity",
-          },
-          {
-            title: "Other",
-            value: "other",
-          },
-        ],
-        initials: "LD",
-        location: "New York, United States",
-      },
-      {
-        id: "3",
-        image: "/images/joseph-gonzalez.jpg",
-        name: "Mr.Joseph G",
-        email: "joseph@email.com",
-        title: "Consultant",
-        expertise: [
-          {
-            title: "Marketing & Brand Development",
-            value: "marketing-and-brand-development",
-          },
-          { title: "General Consultation", value: "general-consultation" },
-          {
-            title: "Partnership Opportunity",
-            value: "partnership-opportunity",
-          },
-          {
-            title: "Other",
-            value: "other",
-          },
-        ],
-        initials: "JG",
-        location: "British Columbia, Canada",
-      },
-    ];
-
-    const consultant = consultants.find((consultant) =>
-      consultant.expertise.some((expertise) =>
-        inquiry.toLowerCase().includes(expertise.value)
-      )
+    if (!email)
+      return new NextResponse("Error: Missing requirement email", {
+        status: 400,
+        statusText: "Error: Missing requirement user email",
+      });
+
+    const consultants = await prisma.consultant.findMany();
+
+    const categories = consultants.map((consultant) =>
+      consultant.expertise.map((expertise) => expertise.title)
     );
+    const flatCategories = categories.flat();
+
+    const uniqueCategories = [...new Set(flatCategories)];
+
+    const response = await openai.responses.create({
+      model: "gpt-5-nano",
+      reasoning: { effort: "high" },
+      instructions: `
+          You are a semantic categorization assistant.
 
-    if (!consultant) {
-      return new NextResponse(JSON.stringify(consultants[0]), { status: 200 });
+        Your task: Match the user's inquiry to the most appropriate category from the provided list.
+        Focus on meaning, intent, and context, not just keyword matches.
+        If the inquiry does not match any category, categorize it as "general inquiry".
+
+        Output format (JSON only, no extra text):
+        {
+          "category": "<matched category or 'general-consultation'>",
+        }
+     `,
+      input: `
+       Categories: ${JSON.stringify(uniqueCategories)}
+              Inquiry:
+              "${inquiry}"
+              `,
+    });
+    const result = JSON.parse(response.output_text);
+
+    let category = result.category;
+    let consultant;
+    console.log("Category:", category);
+
+    if (category) {
+      consultant = consultants.find((consultant) =>
+        consultant.expertise.some((expertise) => expertise.value === category)
+      );
+    } else {
+      consultant = consultants.find((consultant) =>
+        consultant.expertise.some((expertise) =>
+          inquiry.toLowerCase().includes(expertise.value)
+        )
+      );
+      if (consultant) {
+        category =
+          consultant.expertise.find((expertise) =>
+            inquiry.toLowerCase().includes(expertise.value)
+          )?.title ?? "";
+      }
+
+      if (!consultant) {
+        category = "general-consultation";
+        consultant = consultants.find((consultant) =>
+          consultant.expertise.some((expertise) => expertise.value === category)
+        );
+      }
     }
 
-    return new NextResponse(JSON.stringify(consultant), { status: 200 });
+    const mailOptions = {
+      from: `<${email}>`,
+      to: "akinyambo@kondarsoft.com",
+      cc: consultant?.email ?? "",
+      subject: `Contact Form Submission from ${email}`,
+      replyto: `${email}`,
+      html: `<div style="font-family: Arial, sans-serif; font-size: 16px; color: #333;">
+              <h2>New Contact Submission from ${email}</h2>
+                  <p><strong>Inquiry:</strong>${inquiry}</p>
+              </div>
+            `,
+    };
+
+    await transporter.sendMail(mailOptions);
+
+    return new NextResponse(
+      JSON.stringify({ consultant, category: category! }),
+      {
+        status: 200,
+        statusText: "Successfully matched with consultant",
+      }
+    );
   } catch (error) {
     console.error("Error matching with consultant", error);
-    return new NextResponse("Internal server error", { status: 500 });
+    return new NextResponse("Internal server error", {
+      status: 500,
+      statusText: "Internal server error",
+    });
   }
 }
diff --git a/components/matchWithConsultantModal.tsx b/components/matchWithConsultantModal.tsx
index 4bd74b2..7de9c34 100644
--- a/components/matchWithConsultantModal.tsx
+++ b/components/matchWithConsultantModal.tsx
@@ -25,6 +25,7 @@ import {
   FormMessage,
 } from "./ui/form";
 import { Input } from "./ui/input";
+import { toast } from "sonner";
 
 interface MatchWithConsultantModalProps {
   inquiry: string;
@@ -68,6 +69,9 @@ const inquirySchema = z.object({
   inquiry: z
     .string({ message: "Please enter an inquiry." })
     .min(1, { message: "Please enter an inquiry." }),
+  email: z
+    .string({ message: "Please enter a valid email." })
+    .email({ message: "Please enter a valid email." }),
 });
 
 type InquiryData = z.infer<typeof inquirySchema>;
@@ -86,6 +90,7 @@ export function MatchWithConsultantContent({
     resolver: zodResolver(inquirySchema),
     defaultValues: {
       inquiry: "",
+      email: "",
     },
   });
 
@@ -100,8 +105,15 @@ export function MatchWithConsultantContent({
   });
 
   const onSubmit = (data: InquiryData) => {
-    console.log("Submitting.");
-    sumbitInquiry.mutate(data, {});
+    sumbitInquiry.mutate(data, {
+      onSuccess: () => {
+        console.log("Successfully matched with consultant.");
+        inquiryForm.reset();
+      },
+      onError: () => {
+        console.error("Failed to match with consultant.");
+      },
+    });
   };
 
   return (
@@ -173,6 +185,23 @@ export function MatchWithConsultantContent({
                     <FormMessage className="text-red-700/90" />
                   </FormItem>
                 )}
+              />{" "}
+              <FormField
+                control={inquiryForm.control}
+                name="email"
+                render={({ field }) => (
+                  <FormItem className="space-y-2">
+                    <FormLabel htmlFor="inquiry">Email</FormLabel>
+                    <FormControl>
+                      <Input
+                        type="email"
+                        placeholder="jason.c@email.com"
+                        {...field}
+                      />
+                    </FormControl>
+                    <FormMessage className="text-red-700/90" />
+                  </FormItem>
+                )}
               />
               <Button
                 type="submit"
diff --git a/env.ts b/env.ts
index d825dcf..a22b025 100644
--- a/env.ts
+++ b/env.ts
@@ -7,6 +7,7 @@ export const env = createEnv({
         EMAIL_PASSWORD: z.string().min(1),
         CLERK_SIGNING_SECRET: z.string().min(1),
         REDIS_URL: z.string().min(1),
+        OPENAI_API_KEY: z.string().min(1),
     },
     client: {
         NEXT_PUBLIC_AUTHORIZATION_TOKEN: z.string().min(1)
diff --git a/prisma/schema.prisma b/prisma/schema.prisma
index 0de966b..8a3cce6 100644
--- a/prisma/schema.prisma
+++ b/prisma/schema.prisma
@@ -1,132 +1,150 @@
-generator client {
-  provider = "prisma-client-js"
-  // output   = "../lib/generated/prisma"
-}
-
-datasource db {
-  provider = "mongodb"
-  url      = env("DATABASE_URL")
-}
-
-model business {
-  id             String  @id @default(auto()) @map("_id") @db.ObjectId
-  userId         String?
-  firstName      String
-  lastName       String
-  email          String  @unique
-  phone          String?
-  companyName    String
-  companySize    String?
-  industry       String
-  companyWebsite String?
-  description    String?
-
-  @@unique([userId])
-  @@map("businesses")
-}
-
-model individual {
-  id                     String     @id @default(auto()) @map("_id") @db.ObjectId
-  userId                 String?
-  firstName              String
-  lastName               String
-  email                  String     @unique
-  phone                  String?
-  interests              String[]
-  budgetRange            String?
-  addressLine1           String
-  addressLine2           String?
-  city                   String
-  state                  String
-  postalCode             String
-  country                String
-  useSameForBilling      Boolean
-  receiveDeals           Boolean?
-  receiveRecommendations Boolean?
-  Cart                   Cart?
-  wishlists              wishlist[]
-
-  @@unique([userId])
-  @@map("individuals")
-}
-
-model product {
-  id                String         @id @default(auto()) @map("_id") @db.ObjectId
-  category          String
-  description       String
-  estimatedDelivery Json?
-  fastShipping      Boolean
-  image             String
-  inStock           Boolean
-  location          String
-  name              String
-  originalPrice     Float?
-  price             Float
-  rating            Float
-  reviews           Int
-  shippingCosts     Json?
-  shipsTo           String[]
-  tags              String[]
-  vendor            String
-  website           String
-  cartItem          cartItem[]
-  wishlistItems     wishlistItem[]
-
-  @@map("products")
-}
-
-model cartItem {
-  id        String @id @default(auto()) @map("_id") @db.ObjectId
-  cartId    String @db.ObjectId
-  productId String @db.ObjectId
-  quantity  Int
-
-  cart    Cart    @relation(fields: [cartId], references: [id], onDelete: Cascade)
-  product product @relation(fields: [productId], references: [id], onDelete: Cascade)
-
-  @@unique([cartId, productId])
-  @@map("cartItems")
-}
-
-model Cart {
-  id        String  @id @default(auto()) @map("_id") @db.ObjectId
-  userId    String?
-  sessionId String?
-
-  user      individual? @relation(fields: [userId], references: [userId], onDelete: Cascade)
-  cartItem  cartItem[]
-  createdAt DateTime    @default(now())
-  updatedAt DateTime    @updatedAt
-
-  @@unique([userId])
-  @@unique([sessionId])
-  @@map("carts")
-}
-
-model wishlist {
-  id        String  @id @default(auto()) @map("_id") @db.ObjectId
-  userId    String?
-  sessionId String?
-
-  user     individual?    @relation(fields: [userId], references: [userId], onDelete: Cascade)
-  wishList wishlistItem[]
-
-  createdAt DateTime @default(now())
-  updatedAt DateTime @updatedAt
-
-  @@unique([userId])
-  @@unique([sessionId])
-  @@map("wishlists")
-}
-
-model wishlistItem {
-  id         String @id @default(auto()) @map("_id") @db.ObjectId
-  wishlistId String @db.ObjectId
-  productId  String @db.ObjectId
-
-  wishlist wishlist @relation(fields: [wishlistId], references: [id], onDelete: Cascade)
-  product  product  @relation(fields: [productId], references: [id], onDelete: Cascade)
-
-  @@unique([wishlistId, productId])
-  @@map("wishlistItems")
-}
+generator client {
+  provider = "prisma-client-js"
+  // output   = "../lib/generated/prisma"
+}
+
+datasource db {
+  provider = "mongodb"
+  url      = env("DATABASE_URL")
+}
+
+type expertise {
+  title String
+  value String
+}
+
+model business {
+  id             String  @id @default(auto()) @map("_id") @db.ObjectId
+  userId         String?
+  firstName      String
+  lastName       String
+  email          String  @unique
+  phone          String?
+  companyName    String
+  companySize    String?
+  industry       String
+  companyWebsite String?
+  description    String?
+
+  @@unique([userId])
+  @@map("businesses")
+}
+
+model individual {
+  id                     String     @id @default(auto()) @map("_id") @db.ObjectId
+  userId                 String?
+  firstName              String
+  lastName               String
+  email                  String     @unique
+  phone                  String?
+  interests              String[]
+  budgetRange            String?
+  addressLine1           String
+  addressLine2           String?
+  city                   String
+  state                  String
+  postalCode             String
+  country                String
+  useSameForBilling      Boolean
+  receiveDeals           Boolean?
+  receiveRecommendations Boolean?
+  Cart                   Cart?
+  wishlists              wishlist[]
+
+  @@unique([userId])
+  @@map("individuals")
+}
+
+model product {
+  id                String         @id @default(auto()) @map("_id") @db.ObjectId
+  category          String
+  description       String
+  estimatedDelivery Json?
+  fastShipping      Boolean
+  image             String
+  inStock           Boolean
+  location          String
+  name              String
+  originalPrice     Float?
+  price             Float
+  rating            Float
+  reviews           Int
+  shippingCosts     Json?
+  shipsTo           String[]
+  tags              String[]
+  vendor            String
+  website           String
+  cartItem          cartItem[]
+  wishlistItems     wishlistItem[]
+
+  @@map("products")
+}
+
+model cartItem {
+  id        String @id @default(auto()) @map("_id") @db.ObjectId
+  cartId    String @db.ObjectId
+  productId String @db.ObjectId
+  quantity  Int
+
+  cart    Cart    @relation(fields: [cartId], references: [id], onDelete: Cascade)
+  product product @relation(fields: [productId], references: [id], onDelete: Cascade)
+
+  @@unique([cartId, productId])
+  @@map("cartItems")
+}
+
+model Cart {
+  id        String  @id @default(auto()) @map("_id") @db.ObjectId
+  userId    String?
+  sessionId String?
+
+  user      individual? @relation(fields: [userId], references: [userId], onDelete: Cascade)
+  cartItem  cartItem[]
+  createdAt DateTime    @default(now())
+  updatedAt DateTime    @updatedAt
+
+  @@unique([userId])
+  @@unique([sessionId])
+  @@map("carts")
+}
+
+model wishlist {
+  id        String  @id @default(auto()) @map("_id") @db.ObjectId
+  userId    String?
+  sessionId String?
+
+  user     individual?    @relation(fields: [userId], references: [userId], onDelete: Cascade)
+  wishList wishlistItem[]
+
+  createdAt DateTime @default(now())
+  updatedAt DateTime @updatedAt
+
+  @@unique([userId])
+  @@unique([sessionId])
+  @@map("wishlists")
+}
+
+model wishlistItem {
+  id         String @id @default(auto()) @map("_id") @db.ObjectId
+  wishlistId String @db.ObjectId
+  productId  String @db.ObjectId
+
+  wishlist wishlist @relation(fields: [wishlistId], references: [id], onDelete: Cascade)
+  product  product  @relation(fields: [productId], references: [id], onDelete: Cascade)
+
+  @@unique([wishlistId, productId])
+  @@map("wishlistItems")
+}
+
+model consultant {
+  id        String      @id @default(auto()) @map("_id") @db.ObjectId
+  image     String
+  name      String
+  email     String
+  title     String
+  expertise expertise[]
+  initials  String
+  location  String
+
+  @@map("consultants")
+}  
\ No newline at end of file
